<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Photon3Unity3D</name>
    </assembly>
    <members>
        <member name="M:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Photon.SocketServer.Security.DiffieHellmanCryptoProvider"/> class.
            </summary>
        </member>
        <member name="P:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.PublicKey">
            <summary>
            Gets the public key that can be used by another DiffieHellmanCryptoProvider object
            to generate a shared secret agreement.
            </summary>
        </member>
        <member name="M:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.DeriveSharedKey(System.Byte[])">
            <summary>
            Derives the shared key is generated from the secret agreement between two parties,
            given a byte array that contains the second party's public key.
            </summary>
            <param name="otherPartyPublicKey">
            The second party's public key.
            </param>
        </member>
        <member name="T:Photon.SocketServer.Security.ICryptoProvider">
            <summary>Interface for Photon's DiffieHellman/Payload Encryption.</summary>
        </member>
        <member name="T:Photon.SocketServer.Security.OakleyGroups">
            <summary>
            Provides classical Diffie-Hellman Modular Exponentiation Groups defined by the
            OAKLEY Key Determination Protocol (RFC 2412).
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.Generator">
            <summary>
            Gets the genrator (N) used by the the well known groups 1,2 and 5.
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.OakleyPrime768">
            <summary>
            Gets the 768 bit prime for the well known group 1.
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.OakleyPrime1024">
            <summary>
            Gets the 1024 bit prime for the well known group 2.
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.OakleyPrime1536">
            <summary>
            Gets the 1536  bit prime for the well known group 5.
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Hashtable">
            <summary>
            This is a substitute for the Hashtable class, missing in: Win8RT and Windows Phone. It uses a Dictionary&lt;object,object&gt; as base.
            </summary>
            <remarks>
            Please be aware that this class might act differently than the Hashtable equivalent.
            As far as Photon is concerned, the substitution is sufficiently precise.
            </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.Hashtable.Clone">
            <summary>
            Creates a shallow copy of the Hashtable.
            </summary>
            <remarks>
            A shallow copy of a collection copies only the elements of the collection, whether they are
            reference types or value types, but it does not copy the objects that the references refer
            to. The references in the new collection point to the same objects that the references in
            the original collection point to.
            </remarks>
            <returns>Shallow copy of the Hashtable.</returns>
        </member>
        <member name="T:ExitGames.Client.Photon.Encryption.IPhotonEncryptor">
            <summary>Interface for DatagramEncryptor implementations.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.IPhotonEncryptor.Init(System.Byte[],System.Byte[],System.Byte[],System.Boolean)">
            <summary>Initialize the encryptor.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.IPhotonEncryptor.Encrypt(System.Byte[],System.Int32,System.Byte[],System.Int32@,System.Boolean)">
            <summary>Encrypt data.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.IPhotonEncryptor.Decrypt(System.Byte[],System.Int32,System.Int32,System.Int32@,System.Boolean)">
            <summary>Decrypt data.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.IPhotonEncryptor.CreateHMAC(System.Byte[],System.Int32,System.Int32)">
            <summary>Calculates the HMAC for given data.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.IPhotonEncryptor.CheckHMAC(System.Byte[],System.Int32)">
            <summary>Checks if the HMAC of the provided data is correct.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Encryption.EncryptorNet.BLOCK_SIZE">
            <summary>
            Defines block size for encryption/decryption algorithm
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Encryption.EncryptorNet.IV_SIZE">
            <summary>
            Defines reusedIvBytes size for encryption/decryption algorithm
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Encryption.EncryptorNet.HMAC_SIZE">
            <summary>
            Defines HMAC size for packet authentication algorithm
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Encryption.EncryptorNet.encryptorIn">
            <summary>
            Encryption/decryption algorithm implementation
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Encryption.EncryptorNet.hmacsha256In">
            <summary>
            Packet authentication algorithm impelmenation
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Encryption.EncryptorNative">
            <summary>
            Implementation of encryption for "Datagram Encryption".
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Encryption.EncryptorNative.BLOCK_SIZE">
            <summary>
            Defines block size for encryption/decryption algorithm
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Encryption.EncryptorNative.IV_SIZE">
            <summary>
            Defines IV size for encryption/decryption algorithm
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Encryption.EncryptorNative.HMAC_SIZE">
            <summary>
            Defines HMAC size for packet authentication algorithm
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.EncryptorNative.Init(System.Byte[],System.Byte[],System.Byte[],System.Boolean)">
            <summary>
            Initialize
            </summary>
            <param name="encryptionSecret"></param>
            <param name="hmacSecret"></param>
            <param name="ivBytes"></param>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.EncryptorNative.Encrypt(System.Byte[],System.Int32,System.Byte[],System.Int32@,System.Boolean)">
            <summary>
            Encrypts data. puts them into output buffer and prepends with IV
            </summary>
            <param name="data"></param>
            <param name="len"></param>
            <param name="output"></param>
            <param name="offset"></param>
            <param name="ivPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.EncryptorNative.CreateHMAC(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Finishes current HMAC
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.EncryptorNative.Decrypt(System.Byte[],System.Int32,System.Int32,System.Int32@,System.Boolean)">
            <summary>
            Decrypts buffer containing HMAC
            </summary>
            <param name="data">encrypted data prepened by IV</param>
            <param name="offset">offset in the buffer</param>
            <param name="len">len of data to decrypt</param>
            /// <param name="outLen">len of decrypted data</param>
            <param name="ivPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Encryption.EncryptorNative.CheckHMAC(System.Byte[],System.Int32)">
            <summary>
            Checkes wheter data have corect HMAC or not
            </summary>
            <param name="data">buffer with data and HMAC</param>
            <param name="len">len of data including HMAC</param>
            <returns>true if check pass, false otherwise</returns>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetChannel.outgoingReliableUnsequencedNumber">
            <summary>Number for reliable unsequenced commands (separate from "standard" reliable sequenced). Used to avoid duplicates.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetChannel.reliableUnsequencedNumbersCompletelyReceived">
            <summary>The highest number of reliable unsequenced commands that arrived (and all commands before).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetChannel.reliableUnsequencedNumbersReceived">
            <summary>Any reliable unsequenced number that's been received, which is higher than the current highest in complete sequence (reliableUnsequencedNumbersCompletelyReceived).</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetChannel.QueueIncomingReliableUnsequenced(ExitGames.Client.Photon.NCommand)">
            <summary>Checks and queues incoming reliable unsequenced commands ("send" or "fragment"), if they haven't been received yet.</summary>
            <param name="command">The command to check and queue.</param>
            <returns>True if the command is new and got queued (or could be executed/dispatched).</returns>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.sentReliableCommands">
            <summary>One list for all channels keeps sent commands (for re-sending).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.outgoingAcknowledgementsPool">
            <summary>One pool of ACK byte arrays ( 20 bytes each)  for all channels to keep acknowledgements.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.datagramEncryptedConnection">
            <summary>Gets enabled by "request" from server (not by client).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.PeerIdForConnect">
            <summary>Initial PeerId as used in Connect command. If EnableServerTracing is false.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.PeerIdForConnectTrace">
            <summary>Initial PeerId to enable Photon Tracing, as used in Connect command. See: EnableServerTracing.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.DispatchIncomingCommands">
            <summary>
            Checks the incoming queue and Dispatches received data if possible.
            </summary>
            <returns>If a Dispatch happened or not, which shows if more Dispatches might be needed.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.GetFragmentLength">
            <summary>Gets the target size for fragments.</summary>
            <remarks>
            Caches the result for a specific MTU value.
            Fragment length is different, when datagram encryption is used (so this caches two values in fact).
            </remarks>
            <returns></returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.SendAcksOnly">
            <summary>
            gathers acks until udp-packet is full and sends it!
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.SendOutgoingCommands">
            <summary>
            gathers commands from all (out)queues until udp-packet is full and sends it!
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.AreReliableCommandsInTransit">
            <summary>
            Checks if any channel has a outgoing reliable command.
            </summary>
            <returns>True if any channel has a outgoing reliable command. False otherwise.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.EnqueueOperation(System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Byte,ExitGames.Client.Photon.SendOptions,ExitGames.Client.Photon.EgMessageType)">
            <summary>
            Checks connected state and channel before operation is serialized and enqueued for sending.
            </summary>
            <returns>if operation could be enqueued</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.CreateAndEnqueueCommand(System.Byte,ExitGames.Client.Photon.StreamBuffer,System.Byte)">
            <summary>reliable-udp-level function to send some byte[] to the server via un/reliable command</summary>
            <remarks>only called when a custom operation should be send</remarks>
            <returns>the invocation ID for this operation (the payload)</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.SerializeOperationToMessage(System.Byte,System.Collections.Generic.Dictionary{System.Byte,System.Object},ExitGames.Client.Photon.EgMessageType,System.Boolean)">
            <summary>Serializes an operation into our binary messages (magic number, msg-type byte and message). Optionally encrypts.</summary>
            <remarks>This method is mostly the same in EnetPeer, TPeer and HttpPeerBase. Also, for raw messages, we have another variant.</remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.ReceiveIncomingCommands(System.Byte[],System.Int32)">
            <summary>reads incoming udp-packages to create and queue incoming commands*</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.QueueIncomingCommand(ExitGames.Client.Photon.NCommand)">
            <summary>queues incoming commands in the correct order as either unreliable, reliable or unsequenced. return value determines if the command is queued / done.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.RemoveSentReliableCommand(System.Int32,System.Int32,System.Boolean)">
            <summary>removes commands which are acknowledged*</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.StatusCode">
            <summary>
            Enumeration of situations that change the peers internal status.
            Used in calls to OnStatusChanged to inform your application of various situations that might happen.
            </summary>
            <remarks>
            Most of these codes are referenced somewhere else in the documentation when they are relevant to methods.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.Connect">
            <summary>the PhotonPeer is connected.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.Disconnect">
            <summary>the PhotonPeer just disconnected.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.Exception">
            <summary>the PhotonPeer encountered an exception and will disconnect, too.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.ExceptionOnConnect">
            <summary>Exception while opening the incoming connection to the server. Followed by Disconnect.</summary>
            <remarks>The server could be down / not running or the client has no network or a misconfigured DNS.<br/>See {@link PhotonListener#OnStatusChanged}*</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.SecurityExceptionOnConnect">
            <summary>Used on platforms that throw a security exception on connect. Unity3d does this, e.g., if a webplayer build could not fetch a policy-file from a remote server.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.SendError">
            <summary>Sending command failed. Either not connected, or the requested channel is bigger than the number of initialized channels.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.ExceptionOnReceive">
            <summary>Exception, if a server cannot be connected. Followed by Disconnect.</summary>
            <remarks>Most likely, the server is not responding. Ask user to try again later.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TimeoutDisconnect">
            <summary>Disconnection due to a timeout (client did no longer receive ACKs from server). Followed by Disconnect.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServerTimeout">
            <summary>Timeout disconnect by server. The server didn't receive necessary ACKs in time. Followed by Disconnect.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServerUserLimit">
            <summary>Disconnect by server due to concurrent user limit reached (received a disconnect command).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServerLogic">
            <summary>(1043) Disconnect by server due to server's logic. Followed by Disconnect.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServerReasonUnknown">
            <summary>Disconnect by server due to unspecified reason. Followed by Disconnect.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.EncryptionEstablished">
            <summary>(1048) Value for OnStatusChanged()-call, when the encryption-setup for secure communication finished successfully.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.EncryptionFailedToEstablish">
            <summary>(1049) Value for OnStatusChanged()-call, when the encryption-setup failed for some reason. Check debug logs.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.IPhotonPeerListener">
            <summary>
            Callback interface for the Photon client side. Must be provided to a new PhotonPeer in its constructor.
            </summary>
            <remarks>
            These methods are used by your PhotonPeer instance to keep your app updated. Read each method's
            description and check out the samples to see how to use them.
            </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.DebugReturn(ExitGames.Client.Photon.DebugLevel,System.String)">
            <summary>
            Provides textual descriptions for various error conditions and noteworthy situations.
            In cases where the application needs to react, a call to OnStatusChanged is used.
            OnStatusChanged gives "feedback" to the game, DebugReturn provies human readable messages
            on the background.
            </summary>
            <remarks>
            All debug output of the library will be reported through this method. Print it or put it in a
            buffer to use it on-screen. Use PhotonPeer.DebugOut to select how verbose the output is.
            </remarks>
            <param name="level">DebugLevel (severity) of the message.</param>
            <param name="message">Debug text. Print to System.Console or screen.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.OnOperationResponse(ExitGames.Client.Photon.OperationResponse)">
             <summary>
             Callback method which gives you (async) responses for called operations.
             </summary>
             <remarks>
             Similar to method-calling, operations can have a result.
             Because operation-calls are non-blocking and executed on the server, responses are provided
             after a roundtrip as call to this method.
            
             Example: Trying to create a room usually succeeds but can fail if the room's name is already
             in use (room names are their IDs).
            
             This method is used as general callback for all operations. Each response corresponds to a certain
             &quot;type&quot; of operation by its OperationCode.
             <para></para>
             </remarks>
             <example>
             When you join a room, the server will assign a consecutive number to each client: the
             &quot;actorNr&quot; or &quot;player number&quot;. This is sent back in the operation result.<para></para>
            
             Fetch your actorNr of a Join response like this:<para></para>
             <c>int actorNr = (int)operationResponse[(byte)OperationCode.ActorNr];</c>
             </example>
             <param name="operationResponse">The response to an operation\-call.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.OnStatusChanged(ExitGames.Client.Photon.StatusCode)">
             <summary>
             OnStatusChanged is called to let the game know when asynchronous actions finished or when errors happen.
             </summary>
             <remarks>
             Not all of the many StatusCode values will apply to your game. Example: If you don't use encryption,
             the respective status changes are never made.
            
             The values are all part of the StatusCode enumeration and described value-by-value.
             </remarks>
             <param name="statusCode">A code to identify the situation.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.OnEvent(ExitGames.Client.Photon.EventData)">
             <summary>
             Called whenever an event from the Photon Server is dispatched.
             </summary>
             <remarks>
             Events are used for communication between clients and allow the server to update clients anytime.
             The creation of an event is often triggered by an operation (called by this client or an other).
            
             Each event carries a Code plus optional content in its Parameters.
             Your application should identify which content to expect by the event's Code.
            
             Events can be defined and modified server-side.
            
             If you use the LoadBalancing api as basis, several events like EvJoin and EvLeave are pre-defined.
             The LoadBalancing api provides the EventCode and ParameterCode classes for pre-defined events.
            
             Photon also allows you to come up with custom events on the fly, purely client-side.
             To do so, use OpRaiseEvent.<para></para>
            
             Events are incoming messages and as such buffered in the peer.
             Calling PhotonPeer.DispatchIncomingCommands will call IPhotonPeerListener.OnEvent, to hand over received events.
            
             PhotonPeer.ReuseEventInstance is an option to optimize memory usage by reusing one EventData instance.
             </remarks>
             <param name="eventData">The event currently being dispatched.</param>
        </member>
        <member name="F:ExitGames.Client.Photon.IPhotonSocket.Protocol">
            <summary>The protocol for this socket, defined in constructor.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.IPhotonSocket.ConnectAddress">
            <summary>Address, as defined via a Connect() call. Including protocol, port and or path.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.IPhotonSocket.ServerAddress">
            <summary>Contains only the server's hostname (stripped protocol, port and or path). Set in IphotonSocket.Connect().</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.IPhotonSocket.ServerIpAddress">
            <summary>Contains the IP address of the previously resolved ServerAddress (or empty, if GetIpAddress wasn't used).</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.IPhotonSocket.ServerPort">
            <summary>Contains only the server's port address (as string).  Set in IphotonSocket.Connect().</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.IPhotonSocket.AddressResolvedAsIpv6">
            <summary>Where available, this exposes if the server's address was resolved into an IPv6 address or not.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.IPhotonSocket.SerializationProtocol">
             <summary>
             Provides the protocol string, of the current PhotonPeer.SerializationProtocolType to be used for WebSocket connections.
             </summary>
             <remarks>
             Any WebSocket wrapper could access this to get the desired binary protocol for the connection. 
             Some WebSocket implementations use a static value of the same name and need to be updated.
            
             The value is not cached and each call will create the needed string on the fly.
             </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonSocket.TryParseAddress(System.String,System.String@,System.UInt16@,System.String@,System.String@)">
             <summary>
             Separates the given address into address (host name or IP) and port. Port must be included after colon!
             </summary>
             <remarks>
             This method expects any address to include a port. The final ':' in addressAndPort has to separate it.
             IPv6 addresses have multiple colons and <b>must use brackets</b> to separate address from port.
            
             Examples:
                 ns.exitgames.com:5058
                 http://[2001:db8:1f70::999:de8:7648:6e8]:100/
                 [2001:db8:1f70::999:de8:7648:6e8]:100
             See:
                 http://serverfault.com/questions/205793/how-can-one-distinguish-the-host-and-the-port-in-an-ipv6-url
             </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonSocket.IsIpv6SimpleCheck(System.Net.IPAddress)">
            <summary>Implements a (very) simple test if a (valid) IPAddress is IPv6 by testing for colons (:).</summary>
            <remarks>The reason we use this, is that some DotNet platforms don't provide (or allow usage of) the System.Net namespace.</remarks>
            <param name="address">A valid IPAddress or null.</param>
            <returns>If the IPAddress.ToString() contains a colon (which means it's IPv6).</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonSocket.GetIpAddresses(System.String)">
            <summary>Wraps a DNS call to provide an array of addresses, sorted to have the IPv6 ones first.</summary>
            <remarks>
            This skips a DNS lookup, if the hostname is an IPv4 address. Then only this address is used as is.
            The DNS lookup may take a while, so it is recommended to do this in a thread. Also, it may fail entirely.
            </remarks>
            <returns>
            IPAddress array for hostname, sorted to put any IPv6 addresses first.<br/>
            If the DNS lookup fails